diff --git a/src/win/conpty.cc b/src/win/conpty.cc
index 47af75c2d6dd7687ec1fe55a502f11347c52738a..463a85b7d63fc475b06d905e53f8838254c551bf 100644
--- a/src/win/conpty.cc
+++ b/src/win/conpty.cc
@@ -26,17 +26,28 @@
 
 extern "C" void init(v8::Local<v8::Object>);
 
-// Taken from the RS5 Windows SDK, but redefined here in case we're targeting <= 17134
+// Ensure required ConPTY typedefs exist across all Windows SDK versions.
+// Newer SDKs (e.g., 26100) define PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE and HPCON
+// but not the PFN* typedefs. Define missing pieces conditionally.
 #ifndef PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE
-#define PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE \
-  ProcThreadAttributeValue(22, FALSE, TRUE, FALSE)
+#define PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE ProcThreadAttributeValue(22, FALSE, TRUE, FALSE)
+#endif
 
+#ifndef HPCON
 typedef VOID* HPCON;
+#endif
+
+#ifndef PFNCREATEPSEUDOCONSOLE
 typedef HRESULT (__stdcall *PFNCREATEPSEUDOCONSOLE)(COORD c, HANDLE hIn, HANDLE hOut, DWORD dwFlags, HPCON* phpcon);
+#endif
+#ifndef PFNRESIZEPSEUDOCONSOLE
 typedef HRESULT (__stdcall *PFNRESIZEPSEUDOCONSOLE)(HPCON hpc, COORD newSize);
+#endif
+#ifndef PFNCLEARPSEUDOCONSOLE
 typedef HRESULT (__stdcall *PFNCLEARPSEUDOCONSOLE)(HPCON hpc);
+#endif
+#ifndef PFNCLOSEPSEUDOCONSOLE
 typedef void (__stdcall *PFNCLOSEPSEUDOCONSOLE)(HPCON hpc);
-
 #endif
 
 struct pty_baton {
diff --git a/src/win/winpty.cc b/src/win/winpty.cc
index b054dee2194226a823f5c98befdecf06cda2e5dd..9841c504bd9e6ffa676aa7b51ed5f66b246caf59 100644
--- a/src/win/winpty.cc
+++ b/src/win/winpty.cc
@@ -159,22 +159,34 @@ static NAN_METHOD(PtyStartProcess) {
 
   std::string shellpath_(shellpath.begin(), shellpath.end());
 
+  // Predeclare variables to satisfy MSVC goto scoping rules
+  int cols = 0;
+  int rows = 0;
+  bool debug = false;
+  winpty_error_ptr_t error_ptr = nullptr;
+  winpty_config_t* winpty_config = nullptr;
+  winpty_t *pc = nullptr;
+  winpty_spawn_config_t* config = nullptr;
+  HANDLE handle = nullptr;
+  BOOL spawnSuccess = FALSE;
+  v8::Local<v8::Object> marshal;
+
   if (shellpath.empty() || !path_util::file_exists(shellpath)) {
     why << "File not found: " << shellpath_;
     Nan::ThrowError(why.str().c_str());
     goto cleanup;
   }
 
-  int cols = info[4]->Int32Value(Nan::GetCurrentContext()).FromJust();
-  int rows = info[5]->Int32Value(Nan::GetCurrentContext()).FromJust();
-  bool debug = Nan::To<bool>(info[6]).FromJust();
+  cols = info[4]->Int32Value(Nan::GetCurrentContext()).FromJust();
+  rows = info[5]->Int32Value(Nan::GetCurrentContext()).FromJust();
+  debug = Nan::To<bool>(info[6]).FromJust();
 
   // Enable/disable debugging
   SetEnvironmentVariable(WINPTY_DBG_VARIABLE, debug ? "1" : NULL); // NULL = deletes variable
 
   // Create winpty config
-  winpty_error_ptr_t error_ptr = nullptr;
-  winpty_config_t* winpty_config = winpty_config_new(0, &error_ptr);
+  error_ptr = nullptr;
+  winpty_config = winpty_config_new(0, &error_ptr);
   if (winpty_config == nullptr) {
     throw_winpty_error("Error creating WinPTY config", error_ptr);
     goto cleanup;
@@ -185,7 +197,7 @@ static NAN_METHOD(PtyStartProcess) {
   winpty_config_set_initial_size(winpty_config, cols, rows);
 
   // Start the pty agent
-  winpty_t *pc = winpty_open(winpty_config, &error_ptr);
+  pc = winpty_open(winpty_config, &error_ptr);
   winpty_config_free(winpty_config);
   if (pc == nullptr) {
     throw_winpty_error("Error launching WinPTY agent", error_ptr);
@@ -197,7 +209,7 @@ static NAN_METHOD(PtyStartProcess) {
   ptyHandles.insert(ptyHandles.end(), pc);
 
   // Create winpty spawn config
-  winpty_spawn_config_t* config = winpty_spawn_config_new(WINPTY_SPAWN_FLAG_AUTO_SHUTDOWN, shellpath.c_str(), cmdline, cwd, env.c_str(), &error_ptr);
+  config = winpty_spawn_config_new(WINPTY_SPAWN_FLAG_AUTO_SHUTDOWN, shellpath.c_str(), cmdline, cwd, env.c_str(), &error_ptr);
   if (config == nullptr) {
     throw_winpty_error("Error creating WinPTY spawn config", error_ptr);
     goto cleanup;
@@ -205,8 +217,8 @@ static NAN_METHOD(PtyStartProcess) {
   winpty_error_free(error_ptr);
 
   // Spawn the new process
-  HANDLE handle = nullptr;
-  BOOL spawnSuccess = winpty_spawn(pc, config, &handle, nullptr, nullptr, &error_ptr);
+  handle = nullptr;
+  spawnSuccess = winpty_spawn(pc, config, &handle, nullptr, nullptr, &error_ptr);
   winpty_spawn_config_free(config);
   if (!spawnSuccess) {
     throw_winpty_error("Unable to start terminal process", error_ptr);
@@ -215,7 +227,7 @@ static NAN_METHOD(PtyStartProcess) {
   winpty_error_free(error_ptr);
 
   // Set return values
-  v8::Local<v8::Object> marshal = Nan::New<v8::Object>();
+  marshal = Nan::New<v8::Object>();
   Nan::Set(marshal, Nan::New<v8::String>("innerPid").ToLocalChecked(), Nan::New<v8::Number>((int)GetProcessId(handle)));
   Nan::Set(marshal, Nan::New<v8::String>("innerPidHandle").ToLocalChecked(), Nan::New<v8::Number>((int)handle));
   Nan::Set(marshal, Nan::New<v8::String>("pid").ToLocalChecked(), Nan::New<v8::Number>((int)winpty_agent_process(pc)));
