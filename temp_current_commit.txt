/**
 * Session Timeline Service
 * 
 * Manages session timeline items including:
 * - Session messages
 * - Node execution boxes with streaming content
 * - Badge management
 * - Flow debug logs
 */

import { Service } from './base/Service.js'
import { ServiceRegistry } from './base/ServiceRegistry.js'
import type { SessionItem, NodeExecutionBox, Badge, TokenCost, Session } from '../store/types.js'
import type { FlowExecutionArgs } from '../flow-engine/types.js'
import { flowEvents } from '../flow-engine/events.js'
import { broadcastWorkspaceNotification } from '../backend/ws/broadcast.js'
import { UiPayloadCache } from '../core/uiPayloadCache.js'
import { getWorkspaceIdForSessionId } from '../utils/workspace-session.js'

interface SessionTimelineState {
  // Current Node Execution State
  openExecutionBoxes: Record<string, string>

  // LLM Request State
  currentRequestId: string | null
  streamingText: string
  chunkStats: { count: number; totalChars: number }
  retryCount: number
  llmIpcSubscribed: boolean
  doneByRequestId: Record<string, boolean>
}

export class SessionTimelineService extends Service<SessionTimelineState> {
  // Buffers for appendToNodeExecution debouncing
  private textBuffers = new Map<string, string>()
  private badgeQueues = new Map<string, Array<{ type: 'badge'; badge: Badge }>>()
  private flushTimeouts = new Map<string, NodeJS.Timeout>()
  private nodeMetadata = new Map<
    string,
    { nodeLabel: string; nodeKind: string; provider?: string; model?: string }
  >()

  constructor() {
    super({
      openExecutionBoxes: {},
      currentRequestId: null,
      streamingText: '',
      chunkStats: { count: 0, totalChars: 0 },
      retryCount: 0,
      llmIpcSubscribed: false,
      doneByRequestId: {},
    })
  }

  /**
   * Get open execution boxes
   */
  getOpenExecutionBoxes(): Record<string, string> {
    return this.state.openExecutionBoxes
  }

  /**
   * Get current request ID
   */
  getCurrentRequestId(): string | null {
    return this.state.currentRequestId
  }

  /**
   * Add a session item (message, node execution box, etc.)
   */
  addSessionItem(item: Omit<SessionItem, 'id' | 'timestamp'>): void {
    const sessionService = ServiceRegistry.get<any>('session')
    if (!sessionService) return

    const session = sessionService.getCurrentSession()
    if (!session) return

    const newItem: SessionItem = {
      ...item,
      id: crypto.randomUUID(),
      timestamp: Date.now(),
    }

    const workspaceService = ServiceRegistry.get<any>('workspace')
    const ws = workspaceService?.getWorkspaceRoot()
    if (!ws) return

    const sessions = sessionService.getSessionsFor({ workspaceId: ws })
    const updated = sessions.map((s: any) =>
      s.id === session.id
        ? {
            ...s,
            timeline: [...s.timeline, newItem],
            updatedAt: Date.now(),
          }
        : s
    )

    sessionService.setSessionsFor({ workspaceId: ws, sessions: updated })
    sessionService.saveCurrentSession() // Debounced
  }

  /**
   * Update current context
   */
  updateCurrentContext(params: {
    provider?: string
    model?: string
    systemInstructions?: string
    temperature?: number
    messageHistory?: Array<{
      role: 'system' | 'user' | 'assistant'
      content: string
      metadata?: {
        id: string
        pinned?: boolean
        priority?: number
      }
    }>
  }): void {
    const sessionService = ServiceRegistry.get<any>('session')
    if (!sessionService) return

    const session = sessionService.getCurrentSession()
    if (!session) return

    const workspaceService = ServiceRegistry.get<any>('workspace')
    const ws = workspaceService?.getWorkspaceRoot()
    if (!ws) return

    const sessions = sessionService.getSessionsFor({ workspaceId: ws })
    const updated = sessions.map((s: any) =>
      s.id === session.id
        ? {
            ...s,
            currentContext: {
              ...s.currentContext,
              ...params,
            },
            updatedAt: Date.now(),
          }
        : s
    )

    sessionService.setSessionsFor({ workspaceId: ws, sessions: updated })
    sessionService.saveCurrentSession() // Debounced
  }

  /**
   * Start a new context (clear timeline and reset message history)
   */
  async startNewContext(): Promise<void> {
    const sessionService = ServiceRegistry.get<any>('session')
    if (!sessionService) return

    const session = sessionService.getCurrentSession()
    if (!session) return

    const workspaceService = ServiceRegistry.get<any>('workspace')
    const ws = workspaceService?.getWorkspaceRoot()
    if (!ws) return

    const sessions = sessionService.getSessionsFor({ workspaceId: ws })
    const updated = sessions.map((s: any) =>
      s.id === session.id
        ? {
            ...s,
            timeline: [],
            currentContext: {
              ...s.currentContext,
              contextId: crypto.randomUUID(),
              messageHistory: [],
            },
            updatedAt: Date.now(),
          }
        : s
    )

    sessionService.setSessionsFor({ workspaceId: ws, sessions: updated })
    await sessionService.saveCurrentSession(true) // Immediate
  }

  /**
   * Stop current LLM request
   */
  async stopCurrentRequest(): Promise<void> {
    const requestId = this.state.currentRequestId
    if (!requestId) return

    console.log('[SessionTimeline] Stopping request:', requestId)

    try {
      const { stopFlow } = await import('../flow-engine/index.js')
      await stopFlow(requestId)
    } catch (error) {
      console.error('[SessionTimeline] Failed to stop request:', error)
    }

    this.setState({ currentRequestId: null })
  }

  /**
   * No-op in main process (events handled directly by scheduler)
   */
  ensureLlmIpcSubscription(): void {
    // No-op
  }

  /**
   * Add flow debug log
   */
  addFlowDebugLog(log: Omit<NonNullable<Session['flowDebugLogs']>[number], 'timestamp'>): void {
    const sessionService = ServiceRegistry.get<any>('session')
    if (!sessionService) return

    const session = sessionService.getCurrentSession()
    if (!session) return

    const workspaceService = ServiceRegistry.get<any>('workspace')
    const ws = workspaceService?.getWorkspaceRoot()
    if (!ws) return

    const newLog = {
      ...log,
      timestamp: Date.now(),
    }

    const sessions = sessionService.getSessionsFor({ workspaceId: ws })
    const updated = sessions.map((s: any) =>
      s.id === session.id
        ? {
            ...s,
            flowDebugLogs: [...(s.flowDebugLogs || []), newLog],
            updatedAt: Date.now(),
          }
        : s
    )

    sessionService.setSessionsFor({ workspaceId: ws, sessions: updated })
    sessionService.saveCurrentSession() // Debounced
  }

  /**
   * Clear flow debug logs
   */
  clearFlowDebugLogs(): void {
    const sessionService = ServiceRegistry.get<any>('session')
    if (!sessionService) return

    const session = sessionService.getCurrentSession()
    if (!session) return

    const workspaceService = ServiceRegistry.get<any>('workspace')
    const ws = workspaceService?.getWorkspaceRoot()
    if (!ws) return

    const sessions = sessionService.getSessionsFor({ workspaceId: ws })
    const updated = sessions.map((s: any) =>
      s.id === session.id
        ? {
            ...s,
            flowDebugLogs: [],
            updatedAt: Date.now(),
          }
        : s
    )

    sessionService.setSessionsFor({ workspaceId: ws, sessions: updated })
    sessionService.saveCurrentSession() // Debounced
  }

  /**
   * Flush buffered content for a node
   */
  private flushNodeExecution(nodeId: string): void {
    const textBuffer = this.textBuffers.get(nodeId) || ''
    const badgeQueue = this.badgeQueues.get(nodeId) || []

    const contentToAdd: Array<{ type: 'text'; text: string } | { type: 'badge'; badge: Badge }> = []

    // Add buffered text if any
    if (textBuffer) {
      contentToAdd.push({ type: 'text', text: textBuffer })
      this.textBuffers.delete(nodeId)
    }

    // Add queued badges
    if (badgeQueue.length > 0) {
      contentToAdd.push(...badgeQueue)
      this.badgeQueues.delete(nodeId)
    }

    if (contentToAdd.length === 0) return

    // Clear any pending timeout
    const existingTimeout = this.flushTimeouts.get(nodeId)
    if (existingTimeout) {
      clearTimeout(existingTimeout)
      this.flushTimeouts.delete(nodeId)
    }

    // Apply buffered content
    const sessionService = ServiceRegistry.get<any>('session')
    if (!sessionService) return

    const workspaceService = ServiceRegistry.get<any>('workspace')
    const ws = workspaceService?.getWorkspaceRoot()
    if (!ws) return

    const sid = sessionService.getCurrentIdFor({ workspaceId: ws })
    if (!sid) return

    // Find existing open box for this nodeId
    const openBoxId = this.state.openExecutionBoxes[nodeId]
    let newBoxId: string | null = null

    const sessions = sessionService.getSessionsFor({ workspaceId: ws })
    const updated = sessions.map((sess: any) => {
      if (sess.id !== sid) return sess

      const existingBoxIndex = openBoxId
        ? sess.timeline.findIndex((item: any) => item.id === openBoxId)
        : -1

      if (existingBoxIndex !== -1) {
        // Box exists - append content
        const timeline = [...sess.timeline]
        const box = timeline[existingBoxIndex] as NodeExecutionBox
        timeline[existingBoxIndex] = {
          ...box,
          content: [...box.content, ...contentToAdd],
        }

        return {
          ...sess,
          timeline,
          updatedAt: Date.now(),
        }
      } else {
        // First content from this node - create new box
        const metadata = this.nodeMetadata.get(nodeId)
        if (!metadata) return sess

        newBoxId = `box-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
        const newBox: NodeExecutionBox = {
          type: 'node-execution',
          id: newBoxId,
          nodeId,
          nodeLabel: metadata.nodeLabel,
          nodeKind: metadata.nodeKind,
          timestamp: Date.now(),
          content: contentToAdd,
          provider: metadata.provider,
          model: metadata.model,
        }

        return {
          ...sess,
          timeline: [...sess.timeline, newBox],
          updatedAt: Date.now(),
        }
      }
    })

    sessionService.setSessionsFor({ workspaceId: ws, sessions: updated })

    // Update open boxes map if we created a new box
    if (newBoxId) {
      this.setState({
        openExecutionBoxes: {
          ...this.state.openExecutionBoxes,
          [nodeId]: newBoxId,
        },
      })
    }

    // Debounced save
    sessionService.saveCurrentSession()
  }

  /**
   * Append content to node execution box (debounced)
   */
  appendToNodeExecution(params: {
    nodeId: string
    nodeLabel: string
    nodeKind: string
    content: { type: 'text'; text: string } | { type: 'badge'; badge: Badge }
    provider?: string
    model?: string
  }): void {
    const { nodeId, nodeLabel, nodeKind, content, provider, model } = params

    // Store/update metadata for this node
    const existingMetadata = this.nodeMetadata.get(nodeId)
    this.nodeMetadata.set(nodeId, {
      nodeLabel,
      nodeKind,
      provider: provider || existingMetadata?.provider,
      model: model || existingMetadata?.model,
    })

    if (content.type === 'text') {
      // Accumulate text chunks in buffer
      const existing = this.textBuffers.get(nodeId) || ''
      this.textBuffers.set(nodeId, existing + content.text)

      // Debounce flush (100ms)
      const existingTimeout = this.flushTimeouts.get(nodeId)
      if (!existingTimeout) {
        this.flushTimeouts.set(
          nodeId,
          setTimeout(() => this.flushNodeExecution(nodeId), 100)
        )
      }
    } else {
      // Badges are added immediately (flush any pending text first)
      const textBuffer = this.textBuffers.get(nodeId)
      if (textBuffer) {
        this.flushNodeExecution(nodeId)
      }

      const queue = this.badgeQueues.get(nodeId) || []
      queue.push(content)
      this.badgeQueues.set(nodeId, queue)

      // Flush badges immediately
      const existingTimeout = this.flushTimeouts.get(nodeId)
      if (existingTimeout) clearTimeout(existingTimeout)
      this.flushNodeExecution(nodeId)
    }
  }

  /**
   * Update a badge in a node execution box
   */
  updateBadgeInNodeExecution(params: { nodeId: string; badgeId: string; updates: Partial<Badge> }): void {
    const { nodeId, badgeId, updates } = params

    const sessionService = ServiceRegistry.get<any>('session')
    if (!sessionService) return

    const workspaceService = ServiceRegistry.get<any>('workspace')
    const ws = workspaceService?.getWorkspaceRoot()
    if (!ws) return

    const sid = sessionService.getCurrentIdFor({ workspaceId: ws })
    if (!sid) return

    const openBoxId = this.state.openExecutionBoxes[nodeId]
    if (!openBoxId) return

    const sessions = sessionService.getSessionsFor({ workspaceId: ws })
    const updated = sessions.map((sess: any) => {
      if (sess.id !== sid) return sess

      const boxIndex = sess.timeline.findIndex((item: any) => item.id === openBoxId)
      if (boxIndex === -1) return sess

      const timeline = [...sess.timeline]
      const box = timeline[boxIndex] as NodeExecutionBox
      const content = [...box.content]

      // Find and update the badge
      let found = false
      for (let i = 0; i < content.length; i++) {
        const item = content[i]
        if (item.type === 'badge' && item.badge.id === badgeId) {
          content[i] = {
            ...item,
            badge: {
              ...item.badge,
              ...updates,
            },
          }
          found = true
          break
        }
      }

      if (!found) return sess

      timeline[boxIndex] = {
        ...box,
        content,
      }

      return {
        ...sess,
        timeline,
        updatedAt: Date.now(),
      }
    })

    sessionService.setSessionsFor({ workspaceId: ws, sessions: updated })
    sessionService.saveCurrentSession() // Debounced
  }

  /**
   * Finalize node execution box (flush pending content and add cost)
   */
  finalizeNodeExecution(params: { nodeId: string; cost?: TokenCost }): void {
    const { nodeId, cost } = params

    // Flush any pending content
    this.flushNodeExecution(nodeId)

    // Clear metadata
    this.nodeMetadata.delete(nodeId)

    // Add cost if provided
    if (cost) {
      const sessionService = ServiceRegistry.get<any>('session')
      if (!sessionService) return

      const workspaceService = ServiceRegistry.get<any>('workspace')
      const ws = workspaceService?.getWorkspaceRoot()
      if (!ws) return

      const sid = sessionService.getCurrentIdFor({ workspaceId: ws })
      if (!sid) return

      const openBoxId = this.state.openExecutionBoxes[nodeId]
      if (!openBoxId) return

      const sessions = sessionService.getSessionsFor({ workspaceId: ws })
      const updated = sessions.map((sess: any) => {
        if (sess.id !== sid) return sess

        const boxIndex = sess.timeline.findIndex((item: any) => item.id === openBoxId)
        if (boxIndex === -1) return sess

        const timeline = [...sess.timeline]
        const box = timeline[boxIndex] as NodeExecutionBox
        timeline[boxIndex] = {
          ...box,
          cost,
        }

        return {
          ...sess,
          timeline,
          updatedAt: Date.now(),
        }
      })

      sessionService.setSessionsFor({ workspaceId: ws, sessions: updated })
      sessionService.saveCurrentSession() // Debounced
    }

    // Remove from open boxes
    const { [nodeId]: _, ...rest } = this.state.openExecutionBoxes
    this.setState({ openExecutionBoxes: rest })
  }

  // ============================================================================
  // Flow Event Listening (Badge Creation & Timeline Persistence)
  // ============================================================================

  /**
   * Helper: Format tool name for display
   */
  private formatToolName(name: string): string {
    try {
      const parts = String(name || 'Tool').split('.')
      return parts
        .map((p) =>
          p.toLowerCase() === 'fs' ? 'FS' : p.charAt(0).toUpperCase() + p.slice(1)
        )
        .join('.')
    } catch {
      return String(name || 'Tool')
    }
  }

  /**
   * Helper: Normalize tool name for key matching
   */
  private normalizeTool(name: string): { normalized: string; key: string } {
    const normalized = String(name || '').replace(/\./g, '_')
    const key = normalized.replace(/[_.-]/g, '').toLowerCase()
    return { normalized, key }
  }

  /**
   * Helper: Try to parse handle from string or object
   */
  private tryParseHandle(h: any): any | undefined {
    if (!h) return undefined
    if (typeof h === 'object') return h
    if (typeof h === 'string') {
      try {
        return JSON.parse(h)
      } catch {}
    }
    return undefined
  }

  /**
   * Helper: Derive metadata for fs.read_lines tool
   */
  private deriveFsReadLinesMeta(args: any): any {
    try {
      const a = args || {}
      let filePath: string | undefined = a.path
      let lineRange: string | undefined
      const h = this.tryParseHandle(a.handle)
      const s = Number(a.start ?? a.startLine ?? a.start_line)
      const e = Number(a.end ?? a.endLine ?? a.end_line)
      if (!filePath && h && typeof h.path === 'string') filePath = h.path
      if (!isNaN(s) && !isNaN(e) && s > 0 && e >= s) lineRange = `L${s}-${e}`
      else if (!isNaN(s) && s > 0) lineRange = `L${s}`
      return {
        ...(filePath ? { filePath } : {}),
        ...(lineRange ? { lineRange } : {}),
        fullParams: a,
      }
    } catch {
      return undefined
    }
  }

  /**
   * Helper: Derive header for workspace.search tool
   */
  private deriveWorkspaceSearchHeader(args: any): string | undefined {
    try {
      const a = args || {}
      const terms: string[] =
        Array.isArray(a.queries) && a.queries.length
          ? a.queries.map((t: any) => String(t)).filter(Boolean)
          : typeof a.query === 'string'
            ? String(a.query)
                .split('|')
                .map((t) => t.trim())
                .filter(Boolean)
            : []
      if (!terms.length && typeof a.query === 'string') return a.query.trim()
      if (!terms.length) return undefined
      const head = terms.slice(0, 3).join(' | ')
      return head + (terms.length > 3 ? ' ΓÇª' : '')
    } catch {
      return undefined
    }
  }

  /**
   * Helper: Compute line diff statistics
   */
  private computeLineDiff(before?: string, after?: string): { added: number; removed: number } {
    const a = String(before ?? '').split(/\r?\n/)
    const b = String(after ?? '').split(/\r?\n/)
    const n = a.length,
      m = b.length
    if (n === 0 && m === 0) return { added: 0, removed: 0 }
    const LIMIT = 1_000_000
    if (n * m > LIMIT) {
      let i = 0,
        j = 0
      while (i < n && j < m && a[i] === b[j]) {
        i++
        j++
      }
      return { added: m - j, removed: n - i }
    }
    let prev = new Uint32Array(m + 1),
      curr = new Uint32Array(m + 1)
    for (let i = 1; i <= n; i++) {
      const ai = a[i - 1]
      for (let j = 1; j <= m; j++) {
        curr[j] =
          ai === b[j - 1]
            ? prev[j - 1] + 1
            : prev[j] > curr[j - 1]
              ? prev[j]
              : curr[j - 1]
      }
      const tmp = prev
      prev = curr
      curr = tmp
      curr.fill(0)
    }
    const lcs = prev[m]
    return { added: m - lcs, removed: n - lcs }
  }

  /**
   * Start listening to flow events for a specific flow execution
   * Creates node execution boxes, buffers text, manages badges
   *
   * @param requestId - The flow execution request ID
   * @param args - Flow execution arguments
   * @returns Cleanup function to stop listening
   */
  startListeningToFlow(requestId: string, args: FlowExecutionArgs): () => void {
    const sessionId = (args as any).sessionId as string | undefined
    if (!sessionId) {
      return () => {}
    }

    console.log('[SessionTimelineService] startListeningToFlow:', { requestId, sessionId })

    // Build fast node metadata lookup
    const nodeMeta = new Map<string, { label: string; kind: string }>()
    try {
      for (const n of args.flowDef?.nodes || []) {
        const label =
          (n as any)?.data?.label ||
          (n as any)?.data?.labelBase ||
          (n as any)?.data?.nodeType ||
          'Node'
        const kind = (n as any)?.data?.nodeType || (n as any)?.type || 'unknown'
        nodeMeta.set((n as any).id, { label, kind })
      }
    } catch {}

    // Local buffers per node for debounced flushes
    const textBuffers = new Map<string, string>()
    const badgeQueues = new Map<string, any[]>()
    const flushTimeouts = new Map<string, NodeJS.Timeout>()
    const openBoxIds = new Map<string, string>()
    const reasoningBuffers = new Map<string, string>()

    // Track last tool args per tool for header reconstruction on end/error
    const lastToolArgs = new Map<string, any>()

    // Helper: broadcast current session usage snapshot to all renderers
    const broadcastSessionUsage = () => {
      try {
        const sessionService = ServiceRegistry.get<any>('session')
        const workspaceService = ServiceRegistry.get<any>('workspace')
        if (!sessionService || !workspaceService) return

        const ws = getWorkspaceIdForSessionId(sessionId) || workspaceService.getWorkspaceRoot()
        if (!ws) return

        const sessions = sessionService.getSessionsFor({ workspaceId: ws })
        const sess = sessions.find((s: any) => s.id === sessionId)
        if (!sess) return

        const tokenUsage = sess.tokenUsage || {
          total: { inputTokens: 0, outputTokens: 0, totalTokens: 0, cachedTokens: 0 },
          byProvider: {},
          byProviderAndModel: {},
        }
        const costs = sess.costs || {
          byProviderAndModel: {},
          totalCost: 0,
          currency: 'USD',
        }
        const requestsLog = Array.isArray(sess.requestsLog) ? sess.requestsLog : []
        if (ws)
          broadcastWorkspaceNotification(ws, 'session.usage.changed', {
            tokenUsage,
            costs,
            requestsLog,
          })
      } catch (e) {
        console.warn('[SessionTimelineService] broadcastSessionUsage failed', e)
      }
    }

    // Flush function: creates/updates node execution boxes
    const flush = (key: string, immediate = false) => {
      const parts = String(key).split('::')
      const nodeId = parts[0]
      const executionId = parts[1]
      const reasoning = reasoningBuffers.get(key) || ''

      const txt = textBuffers.get(key) || ''
      const badges = badgeQueues.get(key) || []
      if (!txt.trim() && !reasoning && badges.length === 0) {
        // Nothing meaningful to flush
        const pending = flushTimeouts.get(key)
        if (pending) {
          try {
            clearTimeout(pending)
          } catch {}
          flushTimeouts.delete(key)
        }
        return
      }

      const meta = nodeMeta.get(nodeId) || { label: 'Node', kind: 'unknown' }

      const sessionService = ServiceRegistry.get<any>('session')
      const workspaceService = ServiceRegistry.get<any>('workspace')
      if (!sessionService || !workspaceService) return

      const ws = workspaceService.getWorkspaceRoot()
      if (!ws) return

      const sessions = sessionService.getSessionsFor({ workspaceId: ws })
      const idx = sessions.findIndex((sess: any) => sess.id === sessionId)
      if (idx === -1) return

      const sess = sessions[idx]
      const items = Array.isArray(sess.items) ? [...sess.items] : []

      let boxId = openBoxIds.get(key)
      let didCreate = false

      if (!boxId) {
        // Create new box
        boxId = `box-${nodeId}-${executionId || Date.now()}`
        openBoxIds.set(key, boxId)
        const newBox: any = {
          type: 'node-execution',
          id: boxId,
          nodeId,
          executionId,
          nodeLabel: meta.label,
          nodeKind: meta.kind,
          timestamp: Date.now(),
          content: [],
        }
        if (reasoning) newBox.content.push({ type: 'reasoning', text: reasoning })
        if (txt.trim()) newBox.content.push({ type: 'text', text: txt })
        for (const b of badges) newBox.content.push({ type: 'badge', badge: b })
        items.push(newBox)
        didCreate = true
      } else {
        // Update existing box
        const boxIdx = items.findIndex((it: any) => it.type === 'node-execution' && it.id === boxId)
        if (boxIdx >= 0) {
          const box: any = { ...items[boxIdx] }
          if (reasoning) box.content = [...box.content, { type: 'reasoning', text: reasoning }]
          if (txt.trim()) box.content = [...box.content, { type: 'text', text: txt }]
          for (const b of badges) box.content = [...box.content, { type: 'badge', badge: b }]
          items[boxIdx] = box
        } else {
          // Box disappeared (e.g., session switched), create a new one
          openBoxIds.delete(key)
          const newBox: any = {
            type: 'node-execution',
            id: `box-${nodeId}-${executionId || Date.now()}`,
            nodeId,
            executionId,
            nodeLabel: meta.label,
            nodeKind: meta.kind,
            timestamp: Date.now(),
            content: [],
          }
          if (reasoning) newBox.content.push({ type: 'reasoning', text: reasoning })
          if (txt.trim()) newBox.content.push({ type: 'text', text: txt })
          for (const b of badges) newBox.content.push({ type: 'badge', badge: b })
          items.push(newBox)
          didCreate = true
        }
      }

      // Update session
      const updated = { ...sess, items, updatedAt: Date.now(), lastActivityAt: Date.now() }
      const updatedSessions = sessions.slice()
      updatedSessions[idx] = updated
      sessionService.setSessionsFor({ workspaceId: ws, sessions: updatedSessions })

      console.log('[SessionTimelineService] broadcast delta', {
        op: didCreate ? 'upsertBox' : 'appendToBox',
        sessionId,
        nodeId,
        executionId,
        textLen: txt.length,
        reasonLen: reasoning.length,
        badgesLen: badges.length,
      })

      // Broadcast delta to renderers
      try {
        const wsId = getWorkspaceIdForSessionId(sessionId) || ws
        if (!wsId) {
          console.warn(
            `[SessionTimelineService] flush: NO workspace found for session ${sessionId}`
          )
        }

        if (didCreate) {
          if (wsId) {
            console.log(`[SessionTimelineService] Broadcasting upsertBox to workspace ${wsId}:`, {
              sessionId,
              nodeId,
              executionId,
            })
            broadcastWorkspaceNotification(wsId, 'session.timeline.delta', {
              sessionId,
              op: 'upsertBox',
              nodeId,
              executionId,
              append: { text: txt, reasoning, badges },
            })
          }
        } else if (txt.trim() || reasoning || (badges && badges.length)) {
          if (wsId) {
            console.log(`[SessionTimelineService] Broadcasting appendToBox to workspace ${wsId}:`, {
              sessionId,
              nodeId,
              executionId,
              textLen: txt.length,
              reasoningLen: reasoning.length,
              badgesLen: badges.length,
            })
            broadcastWorkspaceNotification(wsId, 'session.timeline.delta', {
              sessionId,
              op: 'appendToBox',
              nodeId,
              executionId,
              append: { text: txt, reasoning, badges },
            })
          }
        }
      } catch (e) {
        console.error(`[SessionTimelineService] flush: broadcast error`, e)
      }

      // Clear local buffers and timeouts
      textBuffers.delete(key)
      reasoningBuffers.delete(key)
      badgeQueues.delete(key)
      const t = flushTimeouts.get(key)
      if (t) {
        clearTimeout(t)
        flushTimeouts.delete(key)
      }

      // Debounced disk save for this specific session
      sessionService.saveCurrentSession()
    }

    const debounceFlush = (key: string) => {
      if (flushTimeouts.has(key)) return
      const t = setTimeout(() => flush(key, false), 100)
      flushTimeouts.set(key, t)
    }

    // Event listener: handle all flow events
    const unsubscribe = flowEvents.onFlowEvent(requestId, (ev: any) => {
      const t = ev?.type
      const nid = ev?.nodeId as string | undefined
      const execId = (ev?.executionId as string | undefined) || undefined

      // Defensive: warn if executionId is missing for events that should have it
      if (
        !execId &&
        nid &&
        (t === 'chunk' ||
          t === 'reasoning' ||
          t === 'toolStart' ||
          t === 'toolEnd' ||
          t === 'toolError' ||
          t === 'tokenUsage')
      ) {
        console.warn(`[SessionTimelineService] Missing executionId for ${t} event on node ${nid}`)
      }

      const key = nid ? `${nid}${execId ? `::${execId}` : ''}` : undefined

      // Handle chunk event (streaming text)
      if (t === 'chunk' && key && nid) {
        const prev = textBuffers.get(key) || ''
        const next = prev + (ev.text ?? '')
        textBuffers.set(key, next)
        debounceFlush(key)
        return
      }

      // Handle reasoning event (streaming reasoning)
      if (t === 'reasoning' && key && nid) {
        const prev = reasoningBuffers.get(key) || ''
        const next = prev + (ev.text ?? '')
        reasoningBuffers.set(key, next)
        debounceFlush(key)
        return
      }

      // Handle badge event (simple badge creation from nodes)
      if (t === 'badge' && key && nid && ev.badge) {
        const arr = badgeQueues.get(key) || []
        arr.push(ev.badge)
        badgeQueues.set(key, arr)
        flush(key, true)
        return
      }

      // Handle badgeUpdate event (update existing badge)
      if (t === 'badgeUpdate' && nid && ev.badgeId && ev.updates) {
        // Find and update the badge in the session timeline
        const sessionService = ServiceRegistry.get<any>('session')
        const workspaceService = ServiceRegistry.get<any>('workspace')
        if (!sessionService || !workspaceService) return

        const ws = workspaceService.getWorkspaceRoot()
        if (!ws) return

        const sessions = sessionService.getSessionsFor({ workspaceId: ws })
        const idx = sessions.findIndex((sess: any) => sess.id === sessionId)
        if (idx === -1) return

        const sess = sessions[idx]
        const items = Array.isArray(sess.items) ? [...sess.items] : []

        // Find the node execution box
        const boxIndex = items
          .slice()
          .reverse()
          .findIndex(
            (it: any) =>
              it.type === 'node-execution' &&
              it.nodeId === nid &&
              (!execId || it.executionId === execId)
          )
        if (boxIndex === -1) return

        const box: any = { ...items[items.length - 1 - boxIndex] }
        const rel = box.content
          .slice()
          .reverse()
          .findIndex((c: any) => c.type === 'badge' && c.badge?.id === ev.badgeId)
        if (rel !== -1) {
          const rev = box.content.length - 1 - rel
          const cur = box.content[rev]
          box.content = box.content.slice()
          box.content[rev] = { type: 'badge', badge: { ...(cur as any).badge, ...ev.updates } }

          items[items.length - 1 - boxIndex] = box
          const updated = { ...sess, items, updatedAt: Date.now(), lastActivityAt: Date.now() }
          const updatedSessions = sessions.slice()
          updatedSessions[idx] = updated
          sessionService.setSessionsFor({ workspaceId: ws, sessions: updatedSessions })

          // Broadcast update
          try {
            const wsId = getWorkspaceIdForSessionId(sessionId) || ws
            if (wsId)
              broadcastWorkspaceNotification(wsId, 'session.timeline.delta', {
                sessionId,
                op: 'updateBadge',
                nodeId: nid,
                executionId: execId,
                badgeId: ev.badgeId,
                updates: ev.updates,
              })
          } catch {}

          // Save session
          sessionService.saveCurrentSession()
        }
        return
      }

      // Handle toolStart event (create badge)
      if (t === 'toolStart' && key && nid) {
        const arr = badgeQueues.get(key) || []
        const label = this.formatToolName(ev.toolName || 'Tool')
        const { normalized, key: tkey } = this.normalizeTool(ev.toolName || '')
        if (ev.toolArgs) {
          try {
            lastToolArgs.set(tkey || normalized, ev.toolArgs)
          } catch {}
        }
        let metadata: any = undefined
        // fs.read_lines: show file path + line range in header
        if (normalized === 'fs_read_lines' || tkey === 'fsreadlines') {
          metadata = this.deriveFsReadLinesMeta(ev.toolArgs)
        }
        // workspace.search: show query header
        if (tkey === 'workspacesearch') {
          const q = this.deriveWorkspaceSearchHeader(ev.toolArgs)
          if (q) metadata = { ...(metadata || {}), query: q, fullParams: ev.toolArgs }
        }
        // fs.write_file: show file path in header
        if (normalized === 'fs_write_file' || tkey === 'fswritefile') {
          const p = ev.toolArgs?.path
          if (p) metadata = { ...(metadata || {}), filePath: p }
        }
        // fs.delete_file: show file path in header
        if (normalized === 'fs_delete_file' || tkey === 'fsdeletefile') {
          const p = ev.toolArgs?.path
          if (p) metadata = { ...(metadata || {}), filePath: p }
        }

        arr.push({
          id: ev.callId || `badge-${Date.now()}`,
          type: 'tool',
          label,
          status: 'running',
          timestamp: Date.now(),
          ...(metadata ? { metadata } : {}),
        })
        badgeQueues.set(key, arr)
        flush(key, true)
        return
      }

      // Handle toolEnd event (update badge with expansion + metadata)
      if (t === 'toolEnd' && nid) {
        // Ensure pending text is flushed
        if (key) flush(key)

        // Build rich badge updates (title already set on start); add expansion + metadata
        const { normalized, key: tkey } = this.normalizeTool(ev.toolName || '')
        const argsUsed = ev.toolArgs || lastToolArgs.get(tkey || normalized) || {}
        const result = ev.result || {}

        let updates: any = { status: 'success', color: 'green' }

        // workspace.search ΓåÆ expandable list of results
        if (tkey === 'workspacesearch') {
          const previewKey = (result as any)?.previewKey
          const count = Number(
            (result as any)?.previewCount ??
              (Array.isArray((result as any)?.data?.results)
                ? (result as any).data.results.length
                : 0) ??
              0
          )
          updates = {
            ...updates,
            expandable: true,
            defaultExpanded: false,
            contentType: 'workspace-search',
            metadata: {
              resultCount: count,
              ...(this.deriveWorkspaceSearchHeader(argsUsed)
                ? { query: this.deriveWorkspaceSearchHeader(argsUsed) }
                : {}),
            },
            // Use provider's previewKey for UI fetch (falls back to callId if missing)
            interactive: { type: 'workspace-search', data: { key: previewKey || ev.callId, count } },
          }
        }

        // fs.read_lines ΓåÆ show file + lines, expandable to full content
        if (normalized === 'fs_read_lines' || tkey === 'fsreadlines') {
          const meta = this.deriveFsReadLinesMeta((result as any)?.usedParams || argsUsed)
          updates = {
            ...updates,
            expandable: true,
            defaultExpanded: false,
            contentType: 'read-lines',
            ...(meta ? { metadata: meta } : {}),
            interactive: { type: 'read-lines', data: { key: ev.callId } },
          }
        }

        // fs.read_file ΓåÆ expandable to raw content
        if (normalized === 'fs_read_file' || tkey === 'fsreadfile') {
          const used = (result as any)?.usedParams || argsUsed
          const filePath = used?.path || used?.file_path
          updates = {
            ...updates,
            expandable: true,
            defaultExpanded: false,
            contentType: 'read-lines',
            ...(filePath ? { metadata: { filePath } } : {}),
            interactive: { type: 'read-lines', data: { key: ev.callId } },
          }
        }

        // fs.write_file / fsWriteFile ΓåÆ single-file diff preview and filename in header
        if (normalized === 'fs_write_file' || tkey === 'fswritefile') {
          const previews = Array.isArray((result as any)?.fileEditsPreview)
            ? (result as any).fileEditsPreview
            : []
          const filePath = (result as any)?.path || argsUsed?.path
          if (previews.length) {
            // Put previews keyed by callId so edits.preview works
            try {
              UiPayloadCache.put(String(ev.callId), previews)
            } catch {}
            // Compute line deltas
            let addedLines = 0,
              removedLines = 0
            for (const f of previews) {
              const { added, removed } = this.computeLineDiff(f.before, f.after)
              addedLines += added
              removedLines += removed
            }
            updates = {
              ...updates,
              expandable: true,
              defaultExpanded: false,
              contentType: 'diff',
              addedLines,
              removedLines,
              filesChanged: previews.length,
              metadata: {
                fileCount: previews.length,
                ...(previews.length === 1 ? { filePath: previews[0]?.path || filePath } : filePath ? { filePath } : {}),
              },
              interactive: { type: 'diff', data: { key: ev.callId, count: previews.length } },
            }
          } else if (filePath) {
            updates = { ...updates, metadata: { filePath } }
          }
        }

        // fs.delete_file ΓåÆ include filename in header (no expansion)
        if (normalized === 'fs_delete_file' || tkey === 'fsdeletefile') {
          const used = (result as any)?.usedParams || argsUsed
          const filePath = (result as any)?.path || used?.path
          if (filePath) {
            updates = { ...updates, metadata: { filePath } }
          }
        }

        // edits.apply / applyPatch / code.applyEditsTargeted ΓåÆ diff preview
        if (tkey === 'applyedits' || tkey === 'applypatch' || tkey === 'codeapplyeditstargeted') {
          const previewKey = (result as any)?.previewKey
          let previews: any[] = []
          if (previewKey) {
            try {
              const p = UiPayloadCache.peek(previewKey)
              if (Array.isArray(p)) previews = p
            } catch {}
          }
          const filesChanged = Number(
            (result as any)?.previewCount || (Array.isArray(previews) ? previews.length : 0) || 0
          )

          // Compute line deltas and single-file header if we have previews
          let addedLines = 0,
            removedLines = 0
          let singleFilePath: string | undefined = undefined
          if (previews.length) {
            if (previews.length === 1 && typeof previews[0]?.path === 'string')
              singleFilePath = String(previews[0].path)
            for (const f of previews) {
              const { added, removed } = this.computeLineDiff(f.before, f.after)
              addedLines += added
              removedLines += removed
            }
          }

          if (filesChanged || previewKey) {
            updates = {
              ...updates,
              expandable: true,
              defaultExpanded: false,
              contentType: 'diff',
              ...(addedLines || removedLines ? { addedLines, removedLines } : {}),
              metadata: {
                fileCount: filesChanged || undefined,
                ...(singleFilePath ? { filePath: singleFilePath } : {}),
              },
              // Use provider's previewKey for UI fetch (falls back to callId if missing)
              interactive: { type: 'diff', data: { key: previewKey || ev.callId, count: filesChanged } },
            }
          }
        }

        // index.search / indexSearch ΓåÆ vector search results
        if (normalized === 'index_search' || tkey === 'indexsearch') {
          const chunks = Array.isArray((result as any)?.chunks) ? (result as any).chunks : []
          if (chunks.length) {
            try {
              UiPayloadCache.put(String(ev.callId), chunks)
            } catch {}
            updates = {
              ...updates,
              expandable: true,
              defaultExpanded: false,
              contentType: 'search',
              metadata: { resultCount: chunks.length },
              interactive: { type: 'search', data: { key: ev.callId, count: chunks.length } },
            }
          }
        }

        // agentAssessTask / agent_assess_task ΓåÆ task assessment
        if (
          normalized === 'agentAssessTask' ||
          normalized === 'agent_assess_task' ||
          tkey === 'agentassesstask'
        ) {
          const assessment = (result as any)?.assessment || {}
          const taskType = typeof assessment.task_type === 'string' ? assessment.task_type : undefined
          const tokenBudget =
            typeof assessment.token_budget === 'number' ? assessment.token_budget : undefined
          const maxIterations =
            typeof assessment.max_iterations === 'number' ? assessment.max_iterations : undefined

          try {
            UiPayloadCache.put(String(ev.callId), result)
          } catch {}

          updates = {
            ...updates,
            expandable: true,
            defaultExpanded: false,
            contentType: 'agent-assess',
            metadata: {
              ...(taskType ? { taskType } : {}),
              ...(tokenBudget !== undefined ? { tokenBudget } : {}),
              ...(maxIterations !== undefined ? { maxIterations } : {}),
            },
            interactive: { type: 'agent-assess', data: { key: ev.callId } },
          }
        }

        // knowledgeBaseSearch / knowledge_base_search ΓåÆ KB search results
        if (
          normalized === 'knowledgeBaseSearch' ||
          normalized === 'knowledge_base_search' ||
          normalized === 'knowledgebase_search'
        ) {
          const resultData = (result as any)?.data || result
          const resultCount =
            typeof resultData.count === 'number'
              ? resultData.count
              : Array.isArray(resultData.results)
                ? resultData.results.length
                : 0

          try {
            UiPayloadCache.put(String(ev.callId), resultData)
          } catch {}

          updates = {
            ...updates,
            expandable: true,
            defaultExpanded: false,
            contentType: 'kb-search',
            metadata: { resultCount },
            interactive: { type: 'kb-search', data: { key: ev.callId, count: resultCount } },
          }
        }

        // knowledgeBaseStore / knowledge_base_store ΓåÆ KB store result
        if (
          normalized === 'knowledgeBaseStore' ||
          normalized === 'knowledge_base_store' ||
          normalized === 'knowledgebase_store'
        ) {
          const data = (result as any)?.data || result || {}
          const filePath = data?.path
          const id = data?.id
          const title = data?.title

          try {
            UiPayloadCache.put(String(ev.callId), data)
          } catch {}

          updates = {
            ...updates,
            expandable: true,
            defaultExpanded: false,
            contentType: 'kb-store',
            metadata: {
              ...(filePath ? { filePath } : {}),
              ...(id ? { id } : {}),
              ...(title ? { title } : {}),
            },
            interactive: { type: 'kb-store', data: { key: ev.callId, id } },
          }
        }

        // workspace.jump / workspaceJump ΓåÆ jump to file result
        if (normalized === 'workspace_jump' || tkey === 'workspacejump') {
          const resultData = (result as any)?.data || result || {}
          const filePath = resultData?.path || resultData?.bestHandle?.path || undefined
          const hasPreview =
            typeof resultData?.preview === 'string' ||
            (Array.isArray(resultData?.results) && resultData.results.length > 0)
          const resultCount = hasPreview ? 1 : 0

          try {
            UiPayloadCache.put(String(ev.callId), resultData)
          } catch {}

          updates = {
            ...updates,
            expandable: true,
            defaultExpanded: false,
            contentType: 'workspace-jump',
            metadata: {
              ...(filePath ? { filePath } : {}),
              resultCount,
            },
            interactive: { type: 'workspace-jump', data: { key: ev.callId, count: resultCount } },
          }
        }

        // workspace.map / workspaceMap ΓåÆ workspace overview
        if (normalized === 'workspace_map' || tkey === 'workspacemap') {
          const resultData = (result as any)?.data || result || {}
          const sectionCount = Array.isArray(resultData?.sections) ? resultData.sections.length : 0

          try {
            UiPayloadCache.put(String(ev.callId), resultData)
          } catch {}

          updates = {
            ...updates,
            expandable: true,
            defaultExpanded: false,
            contentType: 'workspace-map',
            metadata: { resultCount: sectionCount },
            interactive: { type: 'workspace-map', data: { key: ev.callId, count: sectionCount } },
          }
        }

        // code.searchAst / searchAst ΓåÆ AST grep results
        if (normalized === 'code_searchAst' || normalized === 'searchAst' || tkey === 'searchast') {
          const resultData = (result as any)?.data || result || {}
          const matchCount = Array.isArray(resultData?.matches) ? resultData.matches.length : 0

          try {
            UiPayloadCache.put(String(ev.callId), resultData)
          } catch {}

          updates = {
            ...updates,
            expandable: true,
            defaultExpanded: false,
            contentType: 'ast-search',
            metadata: { resultCount: matchCount },
            interactive: { type: 'ast-search', data: { key: ev.callId, count: matchCount } },
          }
        }

        // Apply updates to session
        const sessionService = ServiceRegistry.get<any>('session')
        const workspaceService = ServiceRegistry.get<any>('workspace')
        if (!sessionService || !workspaceService) return

        const ws = workspaceService.getWorkspaceRoot()
        if (!ws) return

        const sessions = sessionService.getSessionsFor({ workspaceId: ws })
        const idx = sessions.findIndex((sess: any) => sess.id === sessionId)
        if (idx === -1) return

        const sess = sessions[idx]
        const items = [...(sess.items || [])]
        let boxIndex = items
          .slice()
          .reverse()
          .findIndex(
            (it: any) =>
              it.type === 'node-execution' && it.nodeId === nid && (!execId || it.executionId === execId)
          )
        if (boxIndex !== -1) {
          boxIndex = items.length - 1 - boxIndex
          const box: any = { ...items[boxIndex] }
          const rel = box.content
            .slice()
            .reverse()
            .findIndex((c: any) => c.type === 'badge' && c.badge?.id === ev.callId)
          if (rel !== -1) {
            const rev = box.content.length - 1 - rel
            const cur = box.content[rev]
            box.content = box.content.slice()
            box.content[rev] = { type: 'badge', badge: { ...(cur as any).badge, ...updates } }

            items[boxIndex] = box
            const updated = { ...sess, items, updatedAt: Date.now(), lastActivityAt: Date.now() }
            const updatedSessions = sessions.slice()
            updatedSessions[idx] = updated
            sessionService.setSessionsFor({ workspaceId: ws, sessions: updatedSessions })
          }
        }

        // Persist & notify renderers
        sessionService.saveCurrentSession()
        try {
          const wsId = getWorkspaceIdForSessionId(sessionId) || ws
          if (wsId)
            broadcastWorkspaceNotification(wsId, 'session.timeline.delta', {
              sessionId,
              op: 'updateBadge',
              nodeId: nid,
              executionId: execId,
              callId: ev.callId,
              updates,
            })
        } catch {}
        return
      }

      // Handle toolError event
      if (t === 'toolError' && key && nid) {
        const arr = badgeQueues.get(key) || []
        arr.push({
          id: ev.callId || `badge-${Date.now()}`,
          type: 'error',
          label: ev.toolName,
          status: 'error',
          error: ev.error,
        })
        badgeQueues.set(key, arr)
        flush(key, true)
        return
      }

      // Handle error event
      if (t === 'error') {
        const k = key || `${nid || 'system'}`
        const arr = badgeQueues.get(k) || []
        arr.push({
          id: `err-${Date.now()}`,
          type: 'error',
          label: 'Error',
          status: 'error',
          error: ev.error,
        })
        badgeQueues.set(k, arr)
        flush(k, true)
        return
      }

      // Handle usageBreakdown event
      if (t === 'usageBreakdown' && key && nid) {
        try {
          const br = (ev as any)?.breakdown
          const usageKey = `usage:${requestId}:${nid}:${execId || '0'}`
          if (br) UiPayloadCache.put(usageKey, br)
          const arr = badgeQueues.get(key) || []
          const meta = {
            inputTokens: br?.totals?.inputTokens,
            outputTokens: br?.totals?.outputTokens,
            totalTokens: br?.totals?.totalTokens,
            estimated: !!br?.estimated,
          }
          arr.push({
            id: `usage-${Date.now()}`,
            type: 'tool',
            label: 'Usage',
            icon: '≡ƒôè',
            color: 'grape',
            variant: 'light',
            status: 'success',
            timestamp: Date.now(),
            expandable: true,
            defaultExpanded: false,
            contentType: 'usage-breakdown',
            interactive: { type: 'usage-breakdown', data: { key: usageKey } },
            metadata: meta,
          })
          badgeQueues.set(key, arr)
          flush(key, true)
        } catch {}
        return
      }

      // Handle tokenUsage event
      if (t === 'tokenUsage') {
        try {
          const { provider, model, usage } = ev
          const sessionService = ServiceRegistry.get<any>('session')
          const workspaceService = ServiceRegistry.get<any>('workspace')
          if (!sessionService || !workspaceService) return

          const ws = workspaceService.getWorkspaceRoot()
          if (!ws) return

          const sessions = sessionService.getSessionsFor({ workspaceId: ws })
          const idx = sessions.findIndex((sess: any) => sess.id === sessionId)
          if (idx === -1) return

          const sess = sessions[idx]
          const items = [...(sess.items || [])]
          let boxIndex = items
            .slice()
            .reverse()
            .findIndex(
              (it: any) =>
                it.type === 'node-execution' &&
                it.nodeId === (ev.nodeId || '') &&
                (!execId || it.executionId === execId)
            )
          if (boxIndex !== -1) {
            boxIndex = items.length - 1 - boxIndex
            const box: any = {
              ...items[boxIndex],
              provider: provider || items[boxIndex].provider,
              model: model || items[boxIndex].model,
              cost: usage || items[boxIndex].cost,
            }
            items[boxIndex] = box
            const updated = { ...sess, items, updatedAt: Date.now(), lastActivityAt: Date.now() }
            const updatedSessions = sessions.slice()
            updatedSessions[idx] = updated
            sessionService.setSessionsFor({ workspaceId: ws, sessions: updatedSessions })
          }
        } catch {}
        // Record usage into session totals (for Tokens & Costs panel)
        try {
          const sessionService = ServiceRegistry.get<any>('session')
          if (sessionService && ev.nodeId && execId) {
            sessionService.recordTokenUsage({
              sessionId,
              requestId,
              nodeId: ev.nodeId,
              executionId: execId,
              provider: ev.provider,
              model: ev.model,
              usage: ev.usage,
            })
          }
        } catch {}
        try {
          const ws = getWorkspaceIdForSessionId(sessionId)
          if (ws)
            broadcastWorkspaceNotification(ws, 'session.timeline.delta', {
              sessionId,
              op: 'updateBoxMeta',
              nodeId: ev.nodeId,
              executionId: execId,
              meta: { provider: ev.provider, model: ev.model, cost: ev.usage },
            })
        } catch {}
        return
      }

      // Handle nodeEnd event
      if (t === 'nodeEnd' && key && nid) {
        flush(key, true)
        openBoxIds.delete(key)
        // Finalize per-node usage into session totals
        try {
          const sessionService = ServiceRegistry.get<any>('session')
          if (sessionService && execId) {
            sessionService.finalizeNodeUsage({
              sessionId,
              requestId,
              nodeId: nid,
              executionId: execId,
            })
          }
        } catch {}
        // Proactively notify usage snapshot so Tokens & Costs panel reacts immediately
        try {
          broadcastSessionUsage()
        } catch {}
        return
      }

      // Handle done event
      if (t === 'done') {
        // Flush any remaining content
        for (const k of Array.from(textBuffers.keys())) flush(k, true)
        for (const k of Array.from(badgeQueues.keys())) flush(k, true)
        // Finalize any remaining usage for this request
        try {
          const tokenTrackingService = ServiceRegistry.get<any>('tokenTracking')
          if (tokenTrackingService) {
            tokenTrackingService.finalizeRequestUsage({ sessionId, requestId })
          }
        } catch {}
        // Proactively notify usage snapshot so Tokens & Costs panel reacts immediately
        try {
          broadcastSessionUsage()
        } catch {}
        return
      }
    })

    return () => {
      console.log('[SessionTimelineService] Cleanup for flow:', requestId)
      try {
        for (const t of flushTimeouts.values()) clearTimeout(t)
      } catch {}
      try {
        unsubscribe()
      } catch {}
    }
  }
}

